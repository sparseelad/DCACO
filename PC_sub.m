function x=PC_sub(L,y,r)

% ===========================================================================
% 
% The CP method was designed to slove the following convex optimization:
% 
%                        min_x f(x)+g(Lx),       (1)
%                        
% where f,g are convex function. L denotes a linear operator.
% 
% The main scheme of the CP method at the k-iteration is given as:
% 
%                         x_{k+1}=prox_{a1*f}(x_k-a1*L'*v_k),
%                                                                        (2)
%                         v_{k+1}=prox_{a2*g^*}(v_k+a2*L(2x_{k+1}-x_k)),
%                         
% where a1,a2>0 are parameters, g^* denotes the conjugate of convex function g,
% prox denotes proxomity operator, definded by
% 
%                        prox_{a*h}(x)=argmin_u{(0.5/a)*||u-x||^2+h(u)}.
%                       
% Under the condition a1*a2*||L||^2<1, iterative sequence {x_k} generated by 
% the CP method converges to the optimal solution to (1) above.
% 
% Each subproblem in SIDCO can be reformulated as 
% 
%                       min f(x)+||Lx||_{infty},      (3)
%                       
% where f is the indicator function of convex ball 
% 
%                      C={x:||x-y||<=r}
%                       =y+{x:||x||_2<=r},
%                      
% that is, f(x)=0, if x belongs C, otherwise, f(x)=+infty. Obviously,
%     
%                     prox_{a1*f}=P_C
%                                =y+(x-y)*(r/max{||x-y||_2,r}).
%                     
% P_C denotes the projection operator onto the closed convex set C.
%     
% If setting g(z)=||z||_{infty}, we know that g^* is the indicator 
% function of convex ball
%                  
%                         D={z:||z||_1<=1}.
% 
% Thus, 
% 
% 
%                         prox_{a2*g^*}=P_D
%                     
% P_D denotes the projection operator onto the closed convex set D.
% 
% 
% By applying the CP method, we can obtain the following scheme to solve (3):
% 
%                      x_{k+1}=P_C(x_k-a1*L'*v_k),
%                                                                  (4)
%                      v_{k+1}=P_D(v_k+a2*L(2x_{k+1}-x_k)).  
%     
% In the following Script, we in fact implement (4) to solve model (3). 
% Note that in the Script, the function "touying_L2ball" computes P_C, and 
% the function "touying_L1ball" computes P_D.
% 
% Good luck.
                     
% ===========================================================================                     
                     
[m,n]=size(L);

subiter=5000; %Number of iteration

c=norm(L,'fro');


%setting parameter
a1=1;
a2=0.999/(a1*c^2);


%initialization
x=zeros(n,1);
v=zeros(m,1);

%main iterations
for k=1:1:subiter
    
    w=x-a1*L'*v;
    xx=touying_L2ball(w,y,r);
    u=v+a2*L*(2*xx-x);
    v=touying_L1ball(u,1);
    
    %stop condition
    if (norm(xx-x)/norm(x)<1e-6),
        break;
    end
    
    x=xx;
    
    
    
end

end
